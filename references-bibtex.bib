
@online{2021,
  title = {Airtable | {{Everyone}}'s App Platform},
  date = {2021},
  url = {https://airtable.com},
  urldate = {2021-04-20},
  abstract = {Airtable is a low-code platform for building collaborative apps. Customize your workflow, collaborate, and achieve ambitious outcomes. Get started for free.},
  file = {/Users/kapayakatongo/Zotero/storage/TP33CA2K/airtable.com.html},
  organization = {{Airtable}}
}

@online{2021a,
  title = {Build an App from a {{Google Sheet}} in Five Minutes, for Free • {{Glide}}},
  date = {2021},
  url = {https://www.glideapps.com/},
  urldate = {2021-03-14},
  abstract = {Glide turns spreadsheets into beautiful, easy-to-use apps, without code. Pick a spreadsheet or start with a template, customize your app, then share it instantly with anyone. Start today for free!},
  file = {/Users/kapayakatongo/Zotero/storage/RBP3GMEJ/www.glideapps.com.html},
  langid = {english}
}

@online{2021b,
  title = {Business {{Apps}} | {{Microsoft Power Apps}}},
  date = {2021},
  url = {https://powerapps.microsoft.com/en-us/},
  urldate = {2021-03-13},
  file = {/Users/kapayakatongo/Zotero/storage/MTIFTGKX/en-us.html}
}

@online{2021c,
  title = {Coda | {{A}} New Doc for Teams.},
  date = {2021},
  url = {https://coda.io/welcome},
  urldate = {2021-03-14},
  abstract = {Coda begins with a blinking cursor and grows as big as your team's ambition. We've seen Coda docs do everything from run weekly meetings, to launch products.},
  file = {/Users/kapayakatongo/Zotero/storage/K2GIIKNJ/welcome.html},
  langid = {american},
  organization = {{Coda | A new doc for teams.}}
}

@online{2021d,
  title = {End-User Programming},
  date = {2021},
  url = {https://www.inkandswitch.com/end-user-programming.html},
  urldate = {2021-02-12},
  abstract = {A vision for empowered computing that reaches back forty years. Our research lab examines why it has been so hard to achieve.},
  file = {/Users/kapayakatongo/Zotero/storage/4BJS5QJJ/end-user-programming.html},
  langid = {american}
}

@online{2021e,
  title = {Helena | {{Web Automation}} for {{End Users}}},
  date = {2021},
  url = {http://helena-lang.org/},
  urldate = {2021-02-12},
  abstract = {Helena is a high-level programming language for web automation.  It comes with Rousillon, a programming-by-demonstration (PBD) tool for writing Helena programs.  Just open the Rousillon browser extension, demonstrate how to collect the first row of a dataset, then let Rousillon write a program for collecting the remaining rows.},
  file = {/Users/kapayakatongo/Zotero/storage/2MD4GXKN/helena-lang.org.html}
}

@online{2021f,
  title = {Tampermonkey for {{Chrome}}},
  date = {2021},
  url = {http://www.tampermonkey.net},
  urldate = {2021-03-13},
  abstract = {Tampermonkey is a free browser extension and the most popular userscript manager. It's available for Chrome, Microsoft Edge, Safari, Opera Next, and Firefox. Even though some of the supported browsers have native userscript support, Tampermonkey will give you much more convenience in managing your userscripts. It provides features like easy script installation, automatic update checks, a simple overview what scripts are running at a tab, a built-in editor and there is a good chance that incompatible scripts run fine with Tampermonkey. So give it a try!},
  file = {/Users/kapayakatongo/Zotero/storage/SQBH8B6U/www.tampermonkey.net.html}
}

@online{2021g,
  title = {What Is {{Microsoft Power Fx}}?},
  date = {2021},
  url = {https://powerapps.microsoft.com/en-us/blog/what-is-microsoft-power-fx/},
  urldate = {2021-03-13},
  abstract = {Microsoft Power Fx is the low code language for expressing logic across the Microsoft Power Platform. \&\#160;It is the same language that is at the heart of Microsoft Power Apps canvas apps\&\#160;today and is inspired by Microsoft Excel.\&\#160; \&\#160;It enables the full spectrum of development from no code to pro code with no cliffs in between, enabling diverse teams to work together and saving everyone time and money.\&\#160; We are very excited to bring it to more of the Power Platform and to share it with everyone as open source.\&\#160; Only through a strong user community can a language grow and flourish.},
  file = {/Users/kapayakatongo/Zotero/storage/6UQUPJ5R/what-is-microsoft-power-fx.html},
  langid = {english}
}

@online{2021h,
  title = {{{AppSheet}}: {{No}}-Code {{App Development}} ~|~ {{Google Cloud}}},
  date = {2021},
  url = {https://cloud.google.com/appsheet},
  urldate = {2021-04-20},
  file = {/Users/kapayakatongo/Zotero/storage/6CVULLYY/appsheet.html}
}

@inproceedings{bakke2016,
  title = {Expressive {{Query Construction}} through {{Direct Manipulation}} of {{Nested Relational Results}}},
  booktitle = {Proceedings of the 2016 {{International Conference}} on {{Management}} of {{Data}}},
  author = {Bakke, Eirik and Karger, David R.},
  date = {2016-06-14},
  pages = {1377--1392},
  publisher = {{ACM}},
  location = {{San Francisco California USA}},
  doi = {10.1145/2882903.2915210},
  url = {https://dl.acm.org/doi/10.1145/2882903.2915210},
  urldate = {2021-04-20},
  abstract = {Despite extensive research on visual query systems, the standard way to interact with relational databases remains to be through SQL queries and tailored form interfaces. We consider three requirements to be essential to a successful alternative: (1) query specification through direct manipulation of results, (2) the ability to view and modify any part of the current query without departing from the direct manipulation interface, and (3) SQL-like expressiveness. This paper presents the first visual query system to meet all three requirements in a single design. By directly manipulating nested relational results, and using spreadsheet idioms such as formulas and filters, the user can express a relationally complete set of query operators plus calculation, aggregation, outer joins, sorting, and nesting, while always remaining able to track and modify the state of the complete query. Our prototype gives the user an experience of responsive, incremental query building while pushing all actual query processing to the database layer. We evaluate our system with formative and controlled user studies on 28 spreadsheet users; the controlled study shows our system significantly outperforming Microsoft Access on the System Usability Scale.},
  eventtitle = {{{SIGMOD}}/{{PODS}}'16: {{International Conference}} on {{Management}} of {{Data}}},
  file = {/Users/kapayakatongo/Zotero/storage/MDEL7XCG/Bakke and Karger - 2016 - Expressive Query Construction through Direct Manip.pdf},
  isbn = {978-1-4503-3531-7},
  langid = {english}
}

@inproceedings{barman2016,
  title = {Ringer: Web Automation by Demonstration},
  shorttitle = {Ringer},
  booktitle = {Proceedings of the 2016 {{ACM SIGPLAN International Conference}} on {{Object}}-{{Oriented Programming}}, {{Systems}}, {{Languages}}, and {{Applications}}},
  author = {Barman, Shaon and Chasins, Sarah and Bodik, Rastislav and Gulwani, Sumit},
  date = {2016-10-19},
  pages = {748--764},
  publisher = {{ACM}},
  location = {{Amsterdam Netherlands}},
  doi = {10.1145/2983990.2984020},
  url = {https://dl.acm.org/doi/10.1145/2983990.2984020},
  urldate = {2021-04-19},
  abstract = {With increasing amounts of data available on the web and a diverse range of users interested in programmatically accessing that data, web automation must become easier. Automation helps users complete many tedious interactions, such as scraping data, completing forms, or transferring data between websites. However, writing web automation scripts typically requires an expert programmer because the writer must be able to reverse engineer the target webpage. We have built a record and replay tool, Ringer, that makes web automation accessible to non-coders. Ringer takes a user demonstration as input and creates a script that interacts with the page as a user would. This approach makes Ringer scripts more robust to webpage changes because user-facing interfaces remain relatively stable compared to the underlying webpage implementations. We evaluated our approach on benchmarks recorded on real webpages and found that it replayed 4x more benchmarks than a state-of-the-art replay tool.},
  eventtitle = {{{SPLASH}} '16: {{Conference}} on {{Systems}}, {{Programming}}, {{Languages}}, and {{Applications}}: {{Software}} for {{Humanity}}},
  file = {/Users/kapayakatongo/Zotero/storage/LBU5WB4P/Barman et al. - 2016 - Ringer web automation by demonstration.pdf},
  isbn = {978-1-4503-4444-9},
  langid = {english}
}

@inproceedings{blackwell2001,
  title = {Cognitive {{Dimensions}} of {{Notations}}: {{Design Tools}} for {{Cognitive Technology}}},
  booktitle = {Cognitive {{Technology}}: {{Instruments}} of {{Mind}}},
  author = {Blackwell, A. F. and Britton, C. and Cox, A. and Green, T. R. G. and Gurr, C. and Kadoda, G. and Kutar, M. S. and Loomes, M. and Nehaniv, C. L. and Petre, M. and Roast, C. and Roe, C. and Wong, A. and Young, R. M.},
  editor = {Beynon, Meurig and Nehaniv, Chrystopher L. and Dautenhahn, Kerstin},
  date = {2001},
  pages = {325--341},
  publisher = {{Springer Berlin Heidelberg}},
  location = {{Berlin, Heidelberg}},
  abstract = {The Cognitive Dimensions of Notations framework has been created to assist the designers of notational systems and information artifacts to evaluate their designs with respect to the impact that they will have on the users of those designs. The framework emphasizes the design choices available to such designers, including characterization of the user’s activity, and the inevitable tradeoffs that will occur between potential design options. The resulting framework has been under development for over 10 years, and now has an active community of researchers devoted to it. This paper first introduces Cognitive Dimensions. It then summarizes the current activity, especially the results of a one-day workshop devoted to Cognitive Dimensions in December 2000, and reviews the ways in which it applies to the field of Cognitive Technology.},
  isbn = {978-3-540-44617-0}
}

@inproceedings{bolin2005,
  title = {Automation and Customization of Rendered Web Pages},
  booktitle = {Proceedings of the 18th Annual {{ACM}} Symposium on {{User}} Interface Software and Technology  - {{UIST}} '05},
  author = {Bolin, Michael and Webber, Matthew and Rha, Philip and Wilson, Tom and Miller, Robert C.},
  date = {2005},
  pages = {163},
  publisher = {{ACM Press}},
  location = {{Seattle, WA, USA}},
  doi = {10.1145/1095034.1095062},
  url = {http://portal.acm.org/citation.cfm?doid=1095034.1095062},
  urldate = {2021-02-11},
  abstract = {On the desktop, an application can expect to control its user interface down to the last pixel, but on the World Wide Web, a content provider has no control over how the client will view the page, once delivered to the browser. This creates an opportunity for end-users who want to automate and customize their web experiences, but the growing complexity of web pages and standards prevents most users from realizing this opportunity. We describe Chickenfoot, a programming system embedded in the Firefox web browser, which enables end-users to automate, customize, and integrate web applications without examining their source code. One way Chickenfoot addresses this goal is a novel technique for identifying page components by keyword pattern matching. We motivate this technique by studying how users name web page components, and present a heuristic keyword matching algorithm that identifies the desired component from the user’s name.},
  eventtitle = {The 18th Annual {{ACM}} Symposium},
  file = {/Users/kapayakatongo/Zotero/storage/CLLTJQD2/Bolin et al. - 2005 - Automation and customization of rendered web pages.pdf},
  isbn = {978-1-59593-271-6},
  langid = {english}
}

@inproceedings{briot2016,
  title = {High {{Responsiveness}} for {{Group Editing CRDTs}}},
  booktitle = {Proceedings of the 19th {{International Conference}} on {{Supporting Group Work}}},
  author = {Briot, Loïck and Urso, Pascal and Shapiro, Marc},
  date = {2016-11-13},
  pages = {51--60},
  publisher = {{ACM}},
  location = {{Sanibel Island Florida USA}},
  doi = {10.1145/2957276.2957300},
  url = {https://dl.acm.org/doi/10.1145/2957276.2957300},
  urldate = {2021-02-11},
  abstract = {Group editing is a crucial feature for many end-user applications. It requires high responsiveness, which can be provided only by optimistic replication algorithms, which come in two classes: classical Operational Transformation (OT), or more recent Conflict-Free Replicated Data Types (CRDTs).},
  eventtitle = {{{GROUP}} '16: 2016 {{ACM Conference}} on {{Supporting Groupwork}}},
  file = {/Users/kapayakatongo/Zotero/storage/4SKSRFT8/Briot et al. - 2016 - High Responsiveness for Group Editing CRDTs.pdf},
  isbn = {978-1-4503-4276-6},
  langid = {english}
}

@inproceedings{chang2014,
  title = {Creating Interactive Web Data Applications with Spreadsheets},
  booktitle = {Proceedings of the 27th Annual {{ACM}} Symposium on {{User}} Interface Software and Technology},
  author = {Chang, Kerry Shih-Ping and Myers, Brad A.},
  date = {2014-10-05},
  pages = {87--96},
  publisher = {{ACM}},
  location = {{Honolulu Hawaii USA}},
  doi = {10.1145/2642918.2647371},
  url = {https://dl.acm.org/doi/10.1145/2642918.2647371},
  urldate = {2021-03-13},
  abstract = {While more and more data are available through web services, it remains difficult for end-users to create web applications that make use of these data without having to write complex code. We present Gneiss, a live programming environment that extends the spreadsheet metaphor to support creating interactive web applications that dynamically use local and web data from multiple sources. Gneiss closely integrates a spreadsheet editor with a web interface builder to let users demonstrate bindings between properties of web GUI elements and cells in the spreadsheet while working with real web service data. The spreadsheet editor provides two-way connections to web services, to both visualize and retrieve different data based on the user input in the web interface. Gneiss achieves rich interactivity without the need for event-based programming by extending the “pull model” of formulas that is familiar to the spreadsheet users. We use a series of examples to demonstrate Gneiss’s ability to create a variety of interactive web data applications.},
  eventtitle = {{{UIST}} '14: {{The}} 27th {{Annual ACM Symposium}} on {{User Interface Software}} and {{Technology}}},
  file = {/Users/kapayakatongo/Zotero/storage/ABHH7U22/Chang and Myers - 2014 - Creating interactive web data applications with sp.pdf},
  isbn = {978-1-4503-3069-5},
  langid = {english}
}

@inproceedings{chasins2018,
  title = {Rousillon: {{Scraping Distributed Hierarchical Web Data}}},
  shorttitle = {Rousillon},
  booktitle = {The 31st {{Annual ACM Symposium}} on {{User Interface Software}} and {{Technology}} - {{UIST}} '18},
  author = {Chasins, Sarah E. and Mueller, Maria and Bodik, Rastislav},
  date = {2018},
  pages = {963--975},
  publisher = {{ACM Press}},
  location = {{Berlin, Germany}},
  doi = {10.1145/3242587.3242661},
  url = {http://dl.acm.org/citation.cfm?doid=3242587.3242661},
  urldate = {2020-01-03},
  abstract = {Programming by Demonstration (PBD) promises to enable data scientists to collect web data. However, in formative interviews with social scientists, we learned that current PBD tools are insufficient for many real-world web scraping tasks. The missing piece is the capability to collect hierarchicallystructured data from across many different webpages. We present Rousillon, a programming system for writing complex web automation scripts by demonstration. Users demonstrate how to collect the first row of a ‘universal table’ view of a hierarchical dataset to teach Rousillon how to collect all rows. To offer this new demonstration model, we developed novel relation selection and generalization algorithms. In a withinsubject user study on 15 computer scientists, users can write hierarchical web scrapers 8 times more quickly with Rousillon than with traditional programming.},
  eventtitle = {The 31st {{Annual ACM Symposium}}},
  file = {/Users/kapayakatongo/Zotero/storage/2KX8Z5XU/Chasins et al. - 2018 - Rousillon Scraping Distributed Hierarchical Web D.pdf},
  isbn = {978-1-4503-5948-1},
  langid = {english}
}

@inproceedings{chugh2016,
  title = {Programmatic and Direct Manipulation, Together at Last},
  booktitle = {Proceedings of the 37th {{ACM SIGPLAN Conference}} on {{Programming Language Design}} and {{Implementation}}},
  author = {Chugh, Ravi and Hempel, Brian and Spradlin, Mitchell and Albers, Jacob},
  date = {2016-06-02},
  pages = {341--354},
  publisher = {{ACM}},
  location = {{Santa Barbara CA USA}},
  doi = {10.1145/2908080.2908103},
  url = {https://dl.acm.org/doi/10.1145/2908080.2908103},
  urldate = {2021-04-14},
  abstract = {Direct manipulation interfaces and programmatic systems have distinct and complementary strengths. The former provide intuitive, immediate visual feedback and enable rapid prototyping, whereas the latter enable complex, reusable abstractions. Unfortunately, existing systems typically force users into just one of these two interaction modes.},
  eventtitle = {{{PLDI}} '16: {{ACM SIGPLAN Conference}} on {{Programming Language Design}} and {{Implementation}}},
  file = {/Users/kapayakatongo/Zotero/storage/LE3SLJMB/Chugh et al. - 2016 - Programmatic and direct manipulation, together at .pdf},
  isbn = {978-1-4503-4261-2},
  langid = {english}
}

@inproceedings{chugh2016a,
  title = {Prodirect Manipulation: Bidirectional Programming for the Masses},
  shorttitle = {Prodirect Manipulation},
  booktitle = {Proceedings of the 38th {{International Conference}} on {{Software Engineering Companion}}},
  author = {Chugh, Ravi},
  date = {2016-05-14},
  pages = {781--784},
  publisher = {{ACM}},
  location = {{Austin Texas}},
  doi = {10.1145/2889160.2889210},
  url = {https://dl.acm.org/doi/10.1145/2889160.2889210},
  urldate = {2021-04-19},
  abstract = {Software interfaces today generally fall at either end of a spectrum. On one end are programmable systems, which allow expert users (i.e. programmers) to write software artifacts that describe complex abstractions, but programs are disconnected from their eventual output. On the other end are domain-specific graphical user interfaces (GUIs), which allow end users (i.e. non-programmers) to easily create varied content but present insurmountable walls when a desired feature is not built-in. Both programmatic and direct manipulation have distinct strengths, but users must typically choose one over the other or use some ad-hoc combination of systems. Our goal, put simply, is to bridge this divide.},
  eventtitle = {{{ICSE}} '16: 38th {{International Conference}} on {{Software Engineering}}},
  file = {/Users/kapayakatongo/Zotero/storage/77PLMHFV/Chugh - 2016 - Prodirect manipulation bidirectional programming .pdf},
  isbn = {978-1-4503-4205-6},
  langid = {english}
}

@online{dexi.io02,
  title = {The Most Powerful Web Scraping Software Available},
  author = {{dexi.io}},
  date = {0002/0021},
  url = {https://webscraping.dexi.io},
  urldate = {2021-02-14},
  abstract = {Advanced web scraping/data extraction software. Scrape data from any online source using our easy-to-use point'n click interface. Dexi.io is a cloud-based web scraping tool which enables you to extract and transform data from any web/cloud source through automation and intelligent mining technology.},
  file = {/Users/kapayakatongo/Zotero/storage/3HQ5CZ2G/webscraping.dexi.io.html},
  langid = {english}
}

@inproceedings{drosos2020,
  title = {Wrex: {{A Unified Programming}}-by-{{Example Interaction}} for {{Synthesizing Readable Code}} for {{Data Scientists}}},
  shorttitle = {Wrex},
  booktitle = {Proceedings of the 2020 {{CHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {Drosos, Ian and Barik, Titus and Guo, Philip J. and DeLine, Robert and Gulwani, Sumit},
  date = {2020-04-21},
  pages = {1--12},
  publisher = {{ACM}},
  location = {{Honolulu HI USA}},
  doi = {10.1145/3313831.3376442},
  url = {https://dl.acm.org/doi/10.1145/3313831.3376442},
  urldate = {2021-02-12},
  abstract = {Data wrangling is a diffcult and time-consuming activity in computational notebooks, and existing wrangling tools do not ft the exploratory workfow for data scientists in these environments. We propose a unifed interaction model based on programming-by-example that generates readable code for a variety of useful data transformations, implemented as a Jupyter notebook extension called WREX. User study results demonstrate that data scientists are signifcantly more effective and effcient at data wrangling with WREX over manual programming. Qualitative participant feedback indicates that WREX was useful and reduced barriers in having to recall or look up the usage of various data transform functions. The synthesized code allowed data scientists to verify the intended data transformation, increased their trust and confdence in WREX, and ft seamlessly within their cell-based notebook workfows. This work suggests that presenting readable code to professional data scientists is an indispensable component of offering data wrangling tools in notebooks.},
  eventtitle = {{{CHI}} '20: {{CHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  file = {/Users/kapayakatongo/Zotero/storage/YZPSRZYE/Drosos et al. - 2020 - Wrex A Unified Programming-by-Example Interaction.pdf},
  isbn = {978-1-4503-6708-0},
  langid = {english}
}

@article{ferdowsifard2020,
  title = {Small-{{Step Live Programming}} by {{Example}}},
  author = {Ferdowsifard, Kasra and Ordookhanians, Allen and Peleg, Hila and Lerner, Sorin and Polikarpova, Nadia},
  date = {2020},
  pages = {13},
  abstract = {Live programming is a paradigm in which the programming environment continually displays runtime values. Program synthesis is a technique that can generate programs or program snippets from examples. Previous works that combine the two have taken a holistic approach to the way examples describe the behavior of functions and programs. This paper presents a new programming paradigm called Small-Step Live Programming by Example that lets the user apply Programming by Example locally. When using Small-Step Live Programming by Example, programmers can change the runtime values displayed by the live visualization to generate local program snippets. We implemented this new paradigm in a tool called SNIPPY, and performed a user study on 13 programmers. Our study fnds that Small-Step Live Programming by Example with SNIPPY helps users solve harder problems faster, and that for certain types of queries, users prefer it to searching the web. Additionally, we identify the user-synthesizer gap, in which users’ mental models of the tool do not match its ability, and needs to be taken into account in the design of future synthesis tools.},
  file = {/Users/kapayakatongo/Zotero/storage/MNWI4377/Ferdowsifard et al. - 2020 - Small-Step Live Programming by Example.pdf},
  langid = {english}
}

@inproceedings{furche2016,
  title = {Robust and {{Noise Resistant Wrapper Induction}}},
  booktitle = {Proceedings of the 2016 {{International Conference}} on {{Management}} of {{Data}}},
  author = {Furche, Tim and Guo, Jinsong and Maneth, Sebastian and Schallhart, Christian},
  date = {2016-06-14},
  pages = {773--784},
  publisher = {{Association for Computing Machinery}},
  location = {{New York, NY, USA}},
  doi = {10.1145/2882903.2915214},
  url = {http://doi.org/10.1145/2882903.2915214},
  urldate = {2021-02-11},
  abstract = {Wrapper induction is the problem of automatically inferring a query from annotated web pages of the same template. This query should not only select the annotated content accurately but also other content following the same template. Beyond accurately matching the template, we consider two additional requirements: (1) wrappers should be robust against a large class of changes to the web pages, and (2) the induction process should be noise resistant, i.e., tolerate slightly erroneous (e.g., machine generated) samples. Key to our approach is a query language that is powerful enough to permit accurate selection, but limited enough to force noisy samples to be generalized into wrappers that select the likely intended items. We introduce such a language as subset of XPATH and show that even for such a restricted language, inducing optimal queries according to a suitable scoring is infeasible. Nevertheless, our wrapper induction framework infers highly robust and noise resistant queries. We evaluate the queries on snapshots from web pages that change over time as provided by the Internet Archive, and show that the induced queries are as robust as the human-made queries. The queries often survive hundreds sometimes thousands of days, with many changes to the relative position of the selected nodes (including changes on template level). This is due to the few and discriminative anchor (intermediately selected) nodes of the generated queries. The queries are highly resistant against positive noise (up to 50\%) and negative noise (up to 20\%).},
  file = {/Users/kapayakatongo/Zotero/storage/XZL3XEJN/Furche et al. - 2016 - Robust and Noise Resistant Wrapper Induction.pdf},
  isbn = {978-1-4503-3531-7},
  keywords = {wrapper,wrapper induction,wrapper maintenance,XPath},
  series = {{{SIGMOD}} '16}
}

@inproceedings{gulwani2014,
  title = {{{NLyze}}: Interactive Programming by Natural Language for Spreadsheet Data Analysis and Manipulation},
  shorttitle = {{{NLyze}}},
  booktitle = {Proceedings of the 2014 {{ACM SIGMOD International Conference}} on {{Management}} of {{Data}}},
  author = {Gulwani, Sumit and Marron, Mark},
  date = {2014-06-18},
  pages = {803--814},
  publisher = {{ACM}},
  location = {{Snowbird Utah USA}},
  doi = {10.1145/2588555.2612177},
  url = {https://dl.acm.org/doi/10.1145/2588555.2612177},
  urldate = {2021-02-11},
  abstract = {Millions of computer end users need to perform tasks over tabular spreadsheet data, yet lack the programming knowledge to do such tasks automatically. This paper describes the design and implementation of a robust natural language based interface to spreadsheet programming. Our methodology involves designing a typed domain-specific language (DSL) that supports an expressive algebra of map, filter, reduce, join, and formatting capabilities at a level of abstraction appropriate for non-expert users. The key algorithmic component of our methodology is a translation algorithm for converting a natural language specification in the context of a given spreadsheet to a ranked set of likely programs in the DSL. The translation algorithm leverages the spreadsheet spatial and temporal context to assign interpretations to specifications with implicit references, and is thus robust to a variety of ways in which end users can express the same task. The translation algorithm builds over ideas from keyword programming and semantic parsing to achieve both high precision and high recall. We implemented the system as an Excel add-in called NLyze that supports a rich user interaction model including annotating the user’s natural language specification and explaining the synthesized DSL programs by paraphrasing them into structured English. We collected a total of 3570 English descriptions for 40 spreadsheet tasks and our system was able to generate the intended interpretation as the top candidate for 94\% (97\% for the top 3) of those instances.},
  eventtitle = {{{SIGMOD}}/{{PODS}}'14: {{International Conference}} on {{Management}} of {{Data}}},
  file = {/Users/kapayakatongo/Zotero/storage/9EMCQJLF/Gulwani and Marron - 2014 - NLyze interactive programming by natural language.pdf},
  isbn = {978-1-4503-2376-5},
  langid = {english}
}

@article{harris,
  title = {Spreadsheet Table Transformations from Examples},
  author = {Harris, William R and Gulwani, Sumit},
  pages = {12},
  abstract = {Every day, millions of computer end-users need to perform tasks over large, tabular data, yet lack the programming knowledge to do such tasks automatically. In this work, we present an automatic technique that takes from a user an example of how the user needs to transform a table of data, and provides to the user a program that implements the transformation described by the example. In particular, we present a language of programs TableProg that can describe transformations that real users require. We then present an algorithm ProgFromEx that takes an example input and output table, and infers a program in TableProg that implements the transformation described by the example. When the program is applied to the example input, it reproduces the example output. When the program is applied to another, potentially larger, table with a “similar” layout as the example input table, then the program produces a corresponding table with a layout that is similar to the example output table. A user can apply ProgFromEx interactively, providing multiple small examples to obtain a program that implements the transformation that the user desires. Moreover, ProgFromEx can help identify “noisy” examples that contain errors.},
  file = {/Users/kapayakatongo/Zotero/storage/T72RLR2R/Harris and Gulwani - Spreadsheet table transformations from examples.pdf},
  langid = {english}
}

@inproceedings{hogue2005,
  title = {Thresher: Automating the Unwrapping of Semantic Content from the {{World Wide Web}}},
  shorttitle = {Thresher},
  booktitle = {Proceedings of the 14th International Conference on {{World Wide Web}}  - {{WWW}} '05},
  author = {Hogue, Andrew and Karger, David},
  date = {2005},
  pages = {86},
  publisher = {{ACM Press}},
  location = {{Chiba, Japan}},
  doi = {10.1145/1060745.1060762},
  url = {http://portal.acm.org/citation.cfm?doid=1060745.1060762},
  urldate = {2020-01-03},
  abstract = {We describe Thresher, a system that lets non-technical users teach their browsers how to extract semantic web content from HTML documents on the World Wide Web. Users specify examples of semantic content by highlighting them in a web browser and describing their meaning. We then use the tree edit distance between the DOM subtrees of these examples to create a general pattern, or wrapper, for the content, and allow the user to bind RDF classes and predicates to the nodes of these wrappers. By overlaying matches to these patterns on standard documents inside the Haystack semantic web browser, we enable a rich semantic interaction with existing web pages, “unwrapping” semantic data buried in the pages’ HTML. By allowing end-users to create, modify, and utilize their own patterns, we hope to speed adoption and use of the Semantic Web and its applications.},
  eventtitle = {The 14th International Conference},
  file = {/Users/kapayakatongo/Zotero/storage/CSUA4TFP/Hogue and Karger - 2005 - Thresher automating the unwrapping of semantic co.pdf},
  isbn = {978-1-59593-046-0},
  langid = {english}
}

@inproceedings{horvitz1999,
  title = {Principles of Mixed-Initiative User Interfaces},
  booktitle = {Proceedings of the {{SIGCHI}} Conference on {{Human}} Factors in Computing Systems the {{CHI}} Is the Limit - {{CHI}} '99},
  author = {Horvitz, Eric},
  date = {1999},
  pages = {159--166},
  publisher = {{ACM Press}},
  location = {{Pittsburgh, Pennsylvania, United States}},
  doi = {10.1145/302979.303030},
  url = {http://portal.acm.org/citation.cfm?doid=302979.303030},
  urldate = {2021-04-20},
  abstract = {Recent debate has centered on the relative promise of focusing user-interface research on developing new metaphors and tools that enhance users’ abilities to directly manipulate objects versus directing effort toward developing interface agents that provide automation. In this paper, we review principles that show promise for allowing engineers to enhance human-computer interaction through an elegant coupling of automated services with direct manipulation. Key ideas will be highlighted in terms of the Lookout system for scheduling and meeting management.},
  eventtitle = {The {{SIGCHI}} Conference},
  file = {/Users/kapayakatongo/Zotero/storage/RHCAZDIX/Horvitz - 1999 - Principles of mixed-initiative user interfaces.pdf},
  isbn = {978-0-201-48559-2},
  langid = {english}
}

@inproceedings{huynh2006,
  title = {Enabling Web Browsers to Augment Web Sites' Filtering and Sorting Functionalities},
  booktitle = {Proceedings of the 19th Annual {{ACM}} Symposium on {{User}} Interface Software and Technology - {{UIST}} '06},
  author = {Huynh, David F. and Miller, Robert C. and Karger, David R.},
  date = {2006},
  pages = {125},
  publisher = {{ACM Press}},
  location = {{Montreux, Switzerland}},
  doi = {10.1145/1166253.1166274},
  url = {http://dl.acm.org/citation.cfm?doid=1166253.1166274},
  urldate = {2020-01-03},
  abstract = {Existing augmentations of web pages are mostly small cosmetic changes (e.g., removing ads) and minor addition of third-party content (e.g., product prices from competing sites). None leverages the structured data presented in web pages. This paper describes Sifter, a web browser extension that can augment a well-structured web site with advanced filtering and sorting functionality. These added features work inside the site’s own pages, preserving the site’s presentational style and the user’s context. Sifter contains an algorithm that scrapes structured data out of well-structured web pages while usually requiring no user intervention. We tested Sifter on real web sites and real users and found that people could use Sifter to perform sophisticated queries and high-level analyses on sizable data collections on the Web. We propose that web sites can be similarly augmented with other sophisticated data-centric functionality, giving users new benefits over the existing Web.},
  eventtitle = {The 19th Annual {{ACM}} Symposium},
  file = {/Users/kapayakatongo/Zotero/storage/BYL9FESG/Huynh et al. - 2006 - Enabling web browsers to augment web sites' filter.pdf},
  isbn = {978-1-59593-313-3},
  langid = {english}
}

@online{import.io,
  title = {Data {{Scraping}} | {{Web Scraping}} | {{Screen Scraping}} | {{Extract}}},
  author = {{import.io}},
  url = {https://www.import.io/product/extract/},
  urldate = {2021-02-14},
  abstract = {Extract | Import.io},
  file = {/Users/kapayakatongo/Zotero/storage/L4QEJ75P/extract.html},
  langid = {american},
  organization = {{Import.io}}
}

@inproceedings{kandel2011,
  title = {Wrangler: Interactive Visual Specification of Data Transformation Scripts},
  shorttitle = {Wrangler},
  booktitle = {Proceedings of the 2011 Annual Conference on {{Human}} Factors in Computing Systems - {{CHI}} '11},
  author = {Kandel, Sean and Paepcke, Andreas and Hellerstein, Joseph and Heer, Jeffrey},
  date = {2011},
  pages = {3363},
  publisher = {{ACM Press}},
  location = {{Vancouver, BC, Canada}},
  doi = {10.1145/1978942.1979444},
  url = {http://dl.acm.org/citation.cfm?doid=1978942.1979444},
  urldate = {2021-03-13},
  abstract = {Though data analysis tools continue to improve, analysts still expend an inordinate amount of time and effort manipulating data and assessing data quality issues. Such “data wrangling” regularly involves reformatting data values or layout, correcting erroneous or missing values, and integrating multiple data sources. These transforms are often difficult to specify and difficult to reuse across analysis tasks, teams, and tools. In response, we introduce Wrangler, an interactive system for creating data transformations. Wrangler combines direct manipulation of visualized data with automatic inference of relevant transforms, enabling analysts to iteratively explore the space of applicable operations and preview their effects. Wrangler leverages semantic data types (e.g., geographic locations, dates, classification codes) to aid validation and type conversion. Interactive histories support review, refinement, and annotation of transformation scripts. User study results show that Wrangler significantly reduces specification time and promotes the use of robust, auditable transforms instead of manual editing.},
  eventtitle = {The 2011 Annual Conference},
  file = {/Users/kapayakatongo/Zotero/storage/MD57H6M8/Kandel et al. - 2011 - Wrangler interactive visual specification of data.pdf},
  isbn = {978-1-4503-0228-9},
  langid = {english}
}

@article{kushmerick2000,
  title = {Wrapper Induction: {{Efficiency}} and Expressiveness},
  shorttitle = {Wrapper Induction},
  author = {Kushmerick, Nicholas},
  date = {2000-04-01},
  journaltitle = {Artificial Intelligence},
  shortjournal = {Artificial Intelligence},
  volume = {118},
  pages = {15--68},
  issn = {0004-3702},
  doi = {10.1016/S0004-3702(99)00100-9},
  url = {https://www.sciencedirect.com/science/article/pii/S0004370299001009},
  urldate = {2021-02-12},
  abstract = {The Internet presents numerous sources of useful information—telephone directories, product catalogs, stock quotes, event listings, etc. Recently, many systems have been built that automatically gather and manipulate such information on a user's behalf. However, these resources are usually formatted for use by people (e.g., the relevant content is embedded in HTML pages), so extracting their content is difficult. Most systems use customized wrapper procedures to perform this extraction task. Unfortunately, writing wrappers is tedious and error-prone. As an alternative, we advocate wrapper induction, a technique for automatically constructing wrappers. In this article, we describe six wrapper classes, and use a combination of empirical and analytical techniques to evaluate the computational tradeoffs among them. We first consider expressiveness: how well the classes can handle actual Internet resources, and the extent to which wrappers in one class can mimic those in another. We then turn to efficiency: we measure the number of examples and time required to learn wrappers in each class, and we compare these results to PAC models of our task and asymptotic complexity analyses of our algorithms. Summarizing our results, we find that most of our wrapper classes are reasonably useful (70\% of surveyed sites can be handled in total), yet can rapidly learned (learning usually requires just a handful of examples and a fraction of a CPU second per example).},
  file = {/Users/kapayakatongo/Zotero/storage/JML9HUSY/Kushmerick - 2000 - Wrapper induction Efficiency and expressiveness.pdf;/Users/kapayakatongo/Zotero/storage/SJ9CGDL9/S0004370299001009.html},
  keywords = {Information agents,Information extraction,Internet information integration,Machine learning,Wrapper induction},
  langid = {english},
  number = {1}
}

@inproceedings{le2014,
  title = {{{FlashExtract}}: A Framework for Data Extraction by Examples},
  shorttitle = {{{FlashExtract}}},
  booktitle = {Proceedings of the 35th {{ACM SIGPLAN Conference}} on {{Programming Language Design}} and {{Implementation}}},
  author = {Le, Vu and Gulwani, Sumit},
  date = {2014-06-09},
  pages = {542--553},
  publisher = {{ACM}},
  location = {{Edinburgh United Kingdom}},
  doi = {10.1145/2594291.2594333},
  url = {https://dl.acm.org/doi/10.1145/2594291.2594333},
  urldate = {2021-04-11},
  abstract = {Various document types that combine model and view (e.g., text files, webpages, spreadsheets) make it easy to organize (possibly hierarchical) data, but make it difficult to extract raw data for any further manipulation or querying. We present a general framework FlashExtract to extract relevant data from semi-structured documents using examples. It includes: (a) an interaction model that allows end-users to give examples to extract various fields and to relate them in a hierarchical organization using structure and sequence constructs. (b) an inductive synthesis algorithm to synthesize the intended program from few examples in any underlying domainspecific language for data extraction that has been built using our specified algebra of few core operators (map, filter, merge, and pair). We describe instantiation of our framework to three different domains: text files, webpages, and spreadsheets. On our benchmark comprising 75 documents, FlashExtract is able to extract intended data using an average of 2.36 examples in 0.84 seconds per field.},
  eventtitle = {{{PLDI}} '14: {{ACM SIGPLAN Conference}} on {{Programming Language Design}} and {{Implementation}}},
  file = {/Users/kapayakatongo/Zotero/storage/UE64B5U4/Le and Gulwani - 2014 - FlashExtract a framework for data extraction by e.pdf},
  isbn = {978-1-4503-2784-8},
  langid = {english}
}

@online{le2017,
  title = {Interactive {{Program Synthesis}}},
  author = {Le, Vu and Perelman, Daniel and Polozov, Oleksandr and Raza, Mohammad and Udupa, Abhishek and Gulwani, Sumit},
  date = {2017-03-09},
  url = {http://arxiv.org/abs/1703.03539},
  urldate = {2021-04-11},
  abstract = {Program synthesis from incomplete specifications (e.g. input-output examples) has gained popularity and found real-world applications, primarily due to its ease-of-use. Since this technology is often used in an interactive setting, efficiency and correctness are often the key user expectations from a system based on such technologies. Ensuring efficiency is challenging since the highly combinatorial nature of program synthesis algorithms does not fit in a 1-2 second response expectation of a user-facing system. Meeting correctness expectations is also difficult, given that the specifications provided are incomplete, and that the users of such systems are typically non-programmers. In this paper, we describe how interactivity can be leveraged to develop efficient synthesis algorithms, as well as to decrease the cognitive burden that a user endures trying to ensure that the system produces the desired program. We build a formal model of user interaction along three dimensions: incremental algorithm, step-based problem formulation, and feedback-based intent refinement. We then illustrate the effectiveness of each of these forms of interactivity with respect to synthesis performance and correctness on a set of real-world case studies.},
  archiveprefix = {arXiv},
  eprint = {1703.03539},
  eprinttype = {arxiv},
  file = {/Users/kapayakatongo/Zotero/storage/X9LFHKW5/Le et al. - 2017 - Interactive Program Synthesis.pdf;/Users/kapayakatongo/Zotero/storage/NKZSED6G/1703.html},
  keywords = {Computer Science - Programming Languages},
  primaryclass = {cs}
}

@inproceedings{ledo2018,
  title = {Evaluation {{Strategies}} for {{HCI Toolkit Research}}},
  booktitle = {Proceedings of the 2018 {{CHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {Ledo, David and Houben, Steven and Vermeulen, Jo and Marquardt, Nicolai and Oehlberg, Lora and Greenberg, Saul},
  date = {2018-04-19},
  pages = {1--17},
  publisher = {{ACM}},
  location = {{Montreal QC Canada}},
  doi = {10.1145/3173574.3173610},
  url = {https://dl.acm.org/doi/10.1145/3173574.3173610},
  urldate = {2021-04-28},
  abstract = {Toolkit research plays an important role in the field of HCI, as it can heavily influence both the design and implementation of interactive systems. For publication, the HCI community typically expects toolkit research to include an evaluation component. The problem is that toolkit evaluation is challenging, as it is often unclear what ‘evaluating’ a toolkit means and what methods are appropriate. To address this problem, we analyzed 68 published toolkit papers. From our analysis, we provide an overview of, reflection on, and discussion of evaluation methods for toolkit contributions. We identify and discuss the value of four toolkit evaluation strategies, including the associated techniques that each employs. We offer a categorization of evaluation strategies for toolkit researchers, along with a discussion of the value, potential limitations, and trade-offs associated with each strategy.},
  eventtitle = {{{CHI}} '18: {{CHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  file = {/Users/kapayakatongo/Zotero/storage/SIEN95TA/Ledo et al. - 2018 - Evaluation Strategies for HCI Toolkit Research.pdf},
  isbn = {978-1-4503-5620-6},
  langid = {english}
}

@inproceedings{leshed2008,
  title = {{{CoScripter}}: Automating \&amp; Sharing How-to Knowledge in the Enterprise},
  shorttitle = {{{CoScripter}}},
  booktitle = {Proceedings of the {{SIGCHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {Leshed, Gilly and Haber, Eben M. and Matthews, Tara and Lau, Tessa},
  date = {2008-04-06},
  pages = {1719--1728},
  publisher = {{Association for Computing Machinery}},
  location = {{New York, NY, USA}},
  doi = {10.1145/1357054.1357323},
  url = {http://doi.org/10.1145/1357054.1357323},
  urldate = {2021-02-11},
  abstract = {Modern enterprises are replete with numerous online processes. Many must be performed frequently and are tedious, while others are done less frequently yet are complex or hard to remember. We present interviews with knowledge workers that reveal a need for mechanisms to automate the execution of and to share knowledge about these processes. In response, we have developed the CoScripter system (formerly Koala [11]), a collaborative scripting environment for recording, automating, and sharing web-based processes. We have deployed CoScripter within a large corporation for more than 10 months. Through usage log analysis and interviews with users, we show that CoScripter has addressed many user automation and sharing needs, to the extent that more than 50 employees have voluntarily incorporated it into their work practice. We also present ways people have used CoScripter and general issues for tools that support automation and sharing of how-to knowledge.},
  file = {/Users/kapayakatongo/Zotero/storage/ZP4I26YJ/Leshed et al. - 2008 - CoScripter automating &amp\; sharing how-to knowle.pdf},
  isbn = {978-1-60558-011-1},
  keywords = {automation,knowledge sharing,procedural knowledge,programming-by-demonstration,scripting,user study,wiki},
  series = {{{CHI}} '08}
}

@inproceedings{lin2009,
  title = {End-User Programming of Mashups with Vegemite},
  booktitle = {Proceedings of the 14th International Conference on {{Intelligent}} User Interfaces},
  author = {Lin, James and Wong, Jeffrey and Nichols, Jeffrey and Cypher, Allen and Lau, Tessa A.},
  date = {2009-02-08},
  pages = {97--106},
  publisher = {{Association for Computing Machinery}},
  location = {{New York, NY, USA}},
  doi = {10.1145/1502650.1502667},
  url = {http://doi.org/10.1145/1502650.1502667},
  urldate = {2021-02-10},
  abstract = {Mashups are an increasingly popular way to integrate data from multiple web sites to fit a particular need, but it often requires substantial technical expertise to create them. To lower the barrier for creating mashups, we have extended the CoScripter web automation tool with a spreadsheet-like environment called Vegemite. Our system uses direct-manipulation and programming-by-demonstration tech-niques to automatically populate tables with information collected from various web sites. A particular strength of our approach is its ability to augment a data set with new values computed by a web site, such as determining the driving distance from a particular location to each of the addresses in a data set. An informal user study suggests that Vegemite may enable a wider class of users to address their information needs.},
  file = {/Users/kapayakatongo/Zotero/storage/4W5ASZ99/Lin et al. - 2009 - End-user programming of mashups with vegemite.pdf},
  isbn = {978-1-60558-168-2},
  keywords = {automation,data integration,end-user programming,mashup,programming by demonstration,web},
  series = {{{IUI}} '09}
}

@inproceedings{litt2020,
  title = {End-User {{Software Customization}} by {{Direct Manipulation}} of {{Tabular Data}}},
  booktitle = {Proceedings of the 2020 {{ACM SIGPLAN International Symposium}} on {{New Ideas}}, {{New Paradigms}}, and {{Reflections}} on {{Programming}} and {{Software}}},
  author = {Litt, Geoffrey and Jackson, Daniel and Millis, Tyler and Quaye, Jessica},
  date = {2020-11-18},
  pages = {18--33},
  publisher = {{ACM}},
  location = {{Virtual USA}},
  doi = {10.1145/3426428.3426914},
  url = {https://dl.acm.org/doi/10.1145/3426428.3426914},
  urldate = {2020-12-20},
  abstract = {Customizing software should be as easy as using it. Unfortunately, most customization methods require users to abruptly shift from using a graphical interface to writing scripts in a programming language.},
  eventtitle = {{{SPLASH}} '20: {{Conference}} on {{Systems}}, {{Programming}}, {{Languages}}, and {{Applications}}, {{Software}} for {{Humanity}}},
  file = {/Users/kapayakatongo/Zotero/storage/6IMQSVW7/Litt et al. - 2020 - End-user software customization by direct manipula.pdf},
  isbn = {978-1-4503-8178-9},
  langid = {english}
}

@inproceedings{litt2020b,
  title = {Wildcard: {{Spreadsheet}}-{{Driven Customization}} of {{Web Applications}}},
  booktitle = {Companion {{Proceedings}} of the 4th {{International Conference}} on the {{Art}}, {{Science}}, and {{Engineering}} of {{Programming}}},
  author = {Litt, Geoffrey and Jackson, Daniel},
  date = {2020},
  pages = {10},
  publisher = {{Association for Computing Machinery}},
  location = {{Porto, Portugal.}},
  doi = {10.1145/3397537.3397541},
  url = {https://doi.org/10.1145/3397537.3397541},
  abstract = {Many Web applications do not meet the precise needs of their users. Browser extensions offer a way to customize web applications, but most people do not have the programming skills to implement their own extensions.},
  eventtitle = {{$<$}{{Programming}}’20{$>$}},
  file = {/Users/kapayakatongo/Zotero/storage/3VZXXDR8/Litt and Jackson - 2020 - Wildcard Spreadsheet-Driven Customization of Web .pdf},
  langid = {english}
}

@incollection{little2010,
  title = {Chapter 15 - {{Sloppy}} Programming},
  booktitle = {No {{Code Required}}},
  author = {Little, Greg and Miller, Robert C. and Chou, Victoria H. and Bernstein, Michael and Lau, Tessa and Cypher, Allen},
  editor = {Cypher, Allen and Dontcheva, Mira and Lau, Tessa and Nichols, Jeffrey},
  date = {2010-01-01},
  pages = {289--307},
  publisher = {{Morgan Kaufmann}},
  location = {{Boston}},
  doi = {10.1016/B978-0-12-381541-5.00015-8},
  url = {https://www.sciencedirect.com/science/article/pii/B9780123815415000158},
  urldate = {2021-02-12},
  abstract = {The essence of sloppy programming is that the user should be able to enter something simple and natural, such as a few keywords, and the computer should try everything within its power to interpret and make sense of this input. This chapter discusses several prototypes that implement sloppy programming, translating sloppy commands directly into executable code. It also describes the algorithms used in these prototypes, exposes their limitations, and proposes directions for future work. The techniques described in this discussion still just scratch the surface of a domain with great potential: translating sloppy commands into executable code. It has described potential benefits to end users and expert programmers alike, as well as advocated a continued need for textual command interfaces. A number of prototypes are discussed exploring this technology and what one can learn from them, including the fact that users can form commands for some of these systems without any training. Finally, it gave some high-level technical details about how to go about actually implementing sloppy translation algorithms, with some references for future reading.},
  file = {/Users/kapayakatongo/Zotero/storage/6HTWZN3G/Little et al. - 2010 - Chapter 15 - Sloppy programming.pdf;/Users/kapayakatongo/Zotero/storage/GX6CVPQX/B9780123815415000158.html},
  isbn = {978-0-12-381541-5},
  langid = {english}
}

@inproceedings{maclean1990,
  title = {User-Tailorable Systems: Pressing the Issues with Buttons},
  shorttitle = {User-Tailorable Systems},
  booktitle = {Proceedings of the {{SIGCHI Conference}} on {{Human Factors}} in {{Computing Systems}}},
  author = {MacLean, Allan and Carter, Kathleen and Lövstrand, Lennart and Moran, Thomas},
  date = {1990-03-01},
  pages = {175--182},
  publisher = {{Association for Computing Machinery}},
  location = {{New York, NY, USA}},
  doi = {10.1145/97243.97271},
  url = {http://doi.org/10.1145/97243.97271},
  urldate = {2021-02-11},
  abstract = {It is impossible to design systems which are appropriate for all users and all situations. We believe that a useful technique is to have end users tailor their systems to match their personal work practices. This requires not only systems which can be tailored, but a culture within which users feel in control of the system and in which tailoring is the norm. In a two-pronged research project we have worked closely with a group of users to develop a system to support tailoring and to help the users evolve a “tailoring culture”. This has resulted in a flexible system based around the use of distributed on-screen Buttons to support a range of tailoring techniques.},
  file = {/Users/kapayakatongo/Zotero/storage/KHDBR75G/MacLean et al. - 1990 - User-tailorable systems pressing the issues with .pdf},
  isbn = {978-0-201-50932-8},
  series = {{{CHI}} '90}
}

@inproceedings{mayer2015,
  title = {User {{Interaction Models}} for {{Disambiguation}} in {{Programming}} by {{Example}}},
  booktitle = {Proceedings of the 28th {{Annual ACM Symposium}} on {{User Interface Software}} \& {{Technology}}},
  author = {Mayer, Mikaël and Soares, Gustavo and Grechkin, Maxim and Le, Vu and Marron, Mark and Polozov, Oleksandr and Singh, Rishabh and Zorn, Benjamin and Gulwani, Sumit},
  date = {2015-11-05},
  pages = {291--301},
  publisher = {{ACM}},
  location = {{Charlotte NC USA}},
  doi = {10.1145/2807442.2807459},
  url = {https://dl.acm.org/doi/10.1145/2807442.2807459},
  urldate = {2021-04-11},
  abstract = {Programming by Examples (PBE) has the potential to revo­ lutionize end-user programming by enabling end users, most of whom are non-programmers, to create small scripts for au­ tomating repetitive tasks. However, examples, though often easy to provide, are an ambiguous specification of the user’s intent. Because of that, a key impedance in adoption of PBE systems is the lack of user confidence in the correctness of the program that was synthesized by the system. We present two novel user interaction models that communicate action­ able information to the user to help resolve ambiguity in the examples. One of these models allows the user to effectively navigate between the huge set of programs that are consis­ tent with the examples provided by the user. The other model uses active learning to ask directed example-based questions to the user on the test input data over which the user intends to run the synthesized program. Our user studies show that each of these models significantly reduces the number of errors in the performed task without any difference in completion time. Moreover, both models are perceived as useful, and the proactive active-learning based model has a slightly higher preference regarding the users’ confidence in the result.},
  eventtitle = {{{UIST}} '15: {{The}} 28th {{Annual ACM Symposium}} on {{User Interface Software}} and {{Technology}}},
  file = {/Users/kapayakatongo/Zotero/storage/XMPVMPK4/Mayer et al. - 2015 - User Interaction Models for Disambiguation in Prog.pdf},
  isbn = {978-1-4503-3779-3},
  langid = {english}
}

@article{meyerovich,
  title = {Flapjax: A Programming Language for {{Ajax}} Applications},
  author = {Meyerovich, Leo A and Guha, Arjun and Baskin, Jacob and Cooper, Gregory H and Greenberg, Michael and Bromfield, Aleks and Krishnamurthi, Shriram},
  pages = {20},
  abstract = {This paper presents Flapjax, a language designed for contemporary Web applications. These applications communicate with servers and have rich, interactive interfaces. Flapjax provides two key features that simplify writing these applications. First, it provides event streams, a uniform abstraction for communication within a program as well as with external Web services. Second, the language itself is reactive: it automatically tracks data dependencies and propagates updates along those dataflows. This allows developers to write reactive interfaces in a declarative and compositional style.},
  file = {/Users/kapayakatongo/Zotero/storage/Y8XLKIKG/Meyerovich et al. - Flapjax a programming language for Ajax applicati.pdf},
  langid = {english}
}

@inproceedings{nilsson2002,
  title = {Functional Reactive Programming, Continued},
  booktitle = {Proceedings of the {{ACM SIGPLAN}} Workshop on {{Haskell}}  - {{Haskell}} '02},
  author = {Nilsson, Henrik and Courtney, Antony and Peterson, John},
  date = {2002},
  pages = {51--64},
  publisher = {{ACM Press}},
  location = {{Pittsburgh, Pennsylvania}},
  doi = {10.1145/581690.581695},
  url = {http://portal.acm.org/citation.cfm?doid=581690.581695},
  urldate = {2021-04-14},
  abstract = {Functional Reactive Programming (FRP) extends a host programming language with a notion of time flow. Arrowized FRP (AFRP) is a version of FRP embedded in Haskell based on the arrow combinators. AFRP is a powerful synchronous dataflow programming language with hybrid modeling capabilities, combining advanced synchronous dataflow features with the higher-order lazy functional abstractions of Haskell. In this paper, we describe the AFRP programming style and our Haskell-based implementation. Of particular interest are the AFRP combinators that support dynamic collections and continuation-based switching. We show how these combinators can be used to express systems with an evolving structure that are difficult to model in more traditional dataflow languages.},
  eventtitle = {The {{ACM SIGPLAN}} Workshop},
  file = {/Users/kapayakatongo/Zotero/storage/LJQ9HT8U/Nilsson et al. - 2002 - Functional reactive programming, continued.pdf},
  isbn = {978-1-58113-605-0},
  langid = {english}
}

@online{octoparse,
  title = {Web {{Scraping Tool}} \& {{Free Web Crawlers}} | {{Octoparse}}},
  author = {Octoparse},
  url = {https://www.octoparse.com/#},
  urldate = {2021-02-14},
  file = {/Users/kapayakatongo/Zotero/storage/VKQUDAHA/www.octoparse.com.html}
}

@online{parsehub,
  title = {{{ParseHub}} | {{Free}} Web Scraping - {{The}} Most Powerful Web Scraper},
  author = {ParseHub},
  url = {https://www.parsehub.com/},
  urldate = {2021-02-14},
  file = {/Users/kapayakatongo/Zotero/storage/KAH396H4/www.parsehub.com.html}
}

@inproceedings{peleg2018,
  title = {Programming Not Only by Example},
  booktitle = {Proceedings of the 40th {{International Conference}} on {{Software Engineering}}},
  author = {Peleg, Hila and Shoham, Sharon and Yahav, Eran},
  date = {2018-05-27},
  pages = {1114--1124},
  publisher = {{ACM}},
  location = {{Gothenburg Sweden}},
  doi = {10.1145/3180155.3180189},
  url = {https://dl.acm.org/doi/10.1145/3180155.3180189},
  urldate = {2021-04-11},
  abstract = {Recent years have seen great progress in automated synthesis techniques that can automatically generate code based on some intent expressed by the programmer, but communicating this intent remains a major challenge. When the expressed intent is coarse-grained (for example, restriction on the expected type of an expression), the synthesizer often produces a long list of results for the programmer to choose from, shifting the heavy-lifting to the user. An alternative approach, successfully used in end-user synthesis, is programming by example (PBE), where the user leverages examples to interactively and iteratively refine the intent. However, using only examples is not expressive enough for programmers, who can observe the generated program and refine the intent by directly relating to parts of the generated program.},
  eventtitle = {{{ICSE}} '18: 40th {{International Conference}} on {{Software Engineering}}},
  file = {/Users/kapayakatongo/Zotero/storage/BYB7PHLG/Peleg et al. - 2018 - Programming not only by example.pdf},
  isbn = {978-1-4503-5638-1},
  langid = {english}
}

@inproceedings{ren2018,
  title = {Reflecting on the {{Evaluation}} of {{Visualization Authoring Systems}} : {{Position Paper}}},
  shorttitle = {Reflecting on the {{Evaluation}} of {{Visualization Authoring Systems}}},
  booktitle = {2018 {{IEEE Evaluation}} and {{Beyond}} - {{Methodological Approaches}} for {{Visualization}} ({{BELIV}})},
  author = {Ren, Donghao and Lee, Bongshin and Brehmer, Matthew and Riche, Nathalie Henry},
  date = {2018-10},
  pages = {86--92},
  doi = {10.1109/BELIV.2018.8634297},
  abstract = {In this paper, we discuss the challenges one faces when evaluating authoring systems developed to help people design visualization for communication purposes. We reflect on our own experiences in evaluating the visualization authoring systems that we have developed as well as the evaluation methods used in other recent projects. We also examine alternative approaches for evaluating visualization authoring systems that we believe to be more appropriate than traditional comparative studies. We hope that our discussion is informative, not only for researchers who intend to develop novel visualization authoring systems, but also for reviewers assigned to evaluate the research contributions of these systems. Our discussion concludes with opportunities for facilitating the evaluation and adoption of deployed visualization authoring systems.},
  eventtitle = {2018 {{IEEE Evaluation}} and {{Beyond}} - {{Methodological Approaches}} for {{Visualization}} ({{BELIV}})},
  file = {/Users/kapayakatongo/Zotero/storage/49YLH2JB/Ren et al. - 2018 - Reflecting on the Evaluation of Visualization Auth.pdf;/Users/kapayakatongo/Zotero/storage/C9TIB9CK/8634297.html},
  keywords = {Authoring systems,Data visualization,Human-centered computing,Layout,Tools,Usability,Videos,Visualization,Visualization design and evaluation methods}
}

@article{satyanarayan2014,
  title = {Lyra: {{An Interactive Visualization Design Environment}}: {{Lyra}}: {{An Interactive Visualization Design Environment}}},
  shorttitle = {Lyra},
  author = {Satyanarayan, Arvind and Heer, Jeffrey},
  date = {2014-06},
  journaltitle = {Computer Graphics Forum},
  shortjournal = {Computer Graphics Forum},
  volume = {33},
  pages = {351--360},
  issn = {01677055},
  doi = {10.1111/cgf.12391},
  url = {http://doi.wiley.com/10.1111/cgf.12391},
  urldate = {2021-04-28},
  abstract = {We present Lyra, an interactive environment for designing customized visualizations without writing code. Using drag-and-drop interactions, designers can bind data to the properties of graphical marks to author expressive visualization designs. Marks can be moved, rotated and resized using handles; relatively positioned using connectors; and parameterized by data fields using property drop zones. Lyra also provides a data pipeline interface for iterative, visual specification of data transformations and layout algorithms. Visualizations created with Lyra are represented as specifications in Vega, a declarative visualization grammar that enables sharing and reuse. We evaluate Lyra’s expressivity and accessibility through diverse examples and studies with journalists and visualization designers. We find that Lyra enables users to rapidly develop customized visualizations, covering a design space comparable to existing programming-based tools.},
  file = {/Users/kapayakatongo/Zotero/storage/7WHUBJ9E/Satyanarayan and Heer - 2014 - Lyra An Interactive Visualization Design Environm.pdf},
  langid = {english},
  number = {3}
}

@inproceedings{satyanarayan2014a,
  title = {Declarative Interaction Design for Data Visualization},
  booktitle = {Proceedings of the 27th Annual {{ACM}} Symposium on {{User}} Interface Software and Technology},
  author = {Satyanarayan, Arvind and Wongsuphasawat, Kanit and Heer, Jeffrey},
  date = {2014-10-05},
  pages = {669--678},
  publisher = {{ACM}},
  location = {{Honolulu Hawaii USA}},
  doi = {10.1145/2642918.2647360},
  url = {https://dl.acm.org/doi/10.1145/2642918.2647360},
  urldate = {2021-04-28},
  abstract = {Declarative visualization grammars can accelerate development, facilitate retargeting across platforms, and allow language-level optimizations. However, existing declarative visualization languages are primarily concerned with visual encoding, and rely on imperative event handlers for interactive behaviors. In response, we introduce a model of declarative interaction design for data visualizations. Adopting methods from reactive programming, we model low-level events as composable data streams from which we form higher-level semantic signals. Signals feed predicates and scale inversions, which allow us to generalize interactive selections at the level of item geometry (pixels) into interactive queries over the data domain. Production rules then use these queries to manipulate the visualization’s appearance. To facilitate reuse and sharing, these constructs can be encapsulated as named interactors: standalone, purely declarative specifications of interaction techniques. We assess our model’s feasibility and expressivity by instantiating it with extensions to the Vega visualization grammar. Through a diverse range of examples, we demonstrate coverage over an established taxonomy of visualization interaction techniques.},
  eventtitle = {{{UIST}} '14: {{The}} 27th {{Annual ACM Symposium}} on {{User Interface Software}} and {{Technology}}},
  file = {/Users/kapayakatongo/Zotero/storage/NQ2HJ46K/Satyanarayan et al. - 2014 - Declarative interaction design for data visualizat.pdf},
  isbn = {978-1-4503-3069-5},
  langid = {english}
}

@article{shipman1999,
  title = {Formality {{Considered Harmful}}: {{Experiences}}, {{Emerging Themes}}, and {{Directions}} on the {{Use}} of {{Formal Representations}} in {{Interactive Systems}}},
  shorttitle = {Formality {{Considered Harmful}}},
  author = {Shipman, Frank M. and Marshall, Catherine C.},
  date = {1999-12},
  journaltitle = {Computer Supported Cooperative Work (CSCW)},
  shortjournal = {Computer Supported Cooperative Work (CSCW)},
  volume = {8},
  pages = {333--352},
  issn = {0925-9724, 1573-7551},
  doi = {10.1023/A:1008716330212},
  url = {http://link.springer.com/10.1023/A:1008716330212},
  urldate = {2021-05-04},
  abstract = {This paper reflects on experiences designing, developing, and working with users of a variety of interactive computer systems. The authors propose, based on these experiences, that the cause of a number of unexpected difficulties in human-computer interaction lies in users’ unwillingness or inability to make structure, content, or procedures explicit. Besides recounting experiences with system use, this paper discusses why users reject or circumvent formalisms which require such explicit expression, and suggests how system designers can anticipate and compensate for problems users have in making implicit aspects of their tasks explicit. The authors propose computational approaches that address this problem, including incremental and system-assisted formalization mechanisms and methods for recognizing and using undeclared structure; they also propose noncomputational solutions that involve designers and users reaching a shared understanding of the task situation and the methods that motivate the formalisms. This paper poses that, while it is impossible to remove all formalisms from computing systems, system designers need to match the level of formal expression entailed with the goals and situation of the users – a design criteria not commonly mentioned in current interface design.},
  file = {/Users/kapayakatongo/Zotero/storage/5SBHDHEJ/Shipman and Marshall - 1999 - Formality Considered Harmful Experiences, Emergin.pdf},
  langid = {english},
  number = {4}
}

@article{tanimoto1990,
  title = {{{VIVA}}: {{A}} Visual Language for Image Processing},
  shorttitle = {{{VIVA}}},
  author = {Tanimoto, Steven L.},
  date = {1990-06},
  journaltitle = {Journal of Visual Languages \& Computing},
  shortjournal = {Journal of Visual Languages \& Computing},
  volume = {1},
  pages = {127--139},
  issn = {1045926X},
  doi = {10.1016/S1045-926X(05)80012-6},
  url = {https://linkinghub.elsevier.com/retrieve/pii/S1045926X05800126},
  urldate = {2021-03-14},
  file = {/Users/kapayakatongo/Zotero/storage/M5B26PE3/Tanimoto - 1990 - VIVA A visual language for image processing.pdf},
  langid = {english},
  number = {2}
}

@inproceedings{tanimoto2013,
  title = {A Perspective on the Evolution of Live Programming},
  booktitle = {2013 1st {{International Workshop}} on {{Live Programming}} ({{LIVE}})},
  author = {Tanimoto, Steven L.},
  date = {2013-05},
  pages = {31--34},
  publisher = {{IEEE}},
  location = {{San Francisco, CA, USA}},
  doi = {10.1109/LIVE.2013.6617346},
  url = {http://ieeexplore.ieee.org/document/6617346/},
  urldate = {2021-03-14},
  abstract = {Liveness in programming environments generally refers to the ability to modify a running program. Liveness is one form of a more general class of behaviors by a programming environment that provide information to programmers about what they are constructing. This paper gives a brief historical perspective on liveness and proposes an extension of a hierarchy given in 1990, to now account for even more powerful executionoriented tools for programmers. In addition, while liveness concerns the timeliness of execution feedback, considering a broader array of forms of feedback is helpful both in better understanding liveness and in designing ever more powerful development tools.},
  eventtitle = {2013 1st {{International Workshop}} on {{Live Programming}} ({{LIVE}})},
  file = {/Users/kapayakatongo/Zotero/storage/VUMK49K6/Tanimoto - 2013 - A perspective on the evolution of live programming.pdf},
  isbn = {978-1-4673-6265-8},
  langid = {english}
}

@inproceedings{zhang2020,
  title = {Interactive {{Program Synthesis}} by {{Augmented Examples}}},
  booktitle = {Proceedings of the 33rd {{Annual ACM Symposium}} on {{User Interface Software}} and {{Technology}}},
  author = {Zhang, Tianyi and Lowmanstone, London and Wang, Xinyu and Glassman, Elena L.},
  date = {2020-10-20},
  pages = {627--648},
  publisher = {{ACM}},
  location = {{Virtual Event USA}},
  doi = {10.1145/3379337.3415900},
  url = {https://dl.acm.org/doi/10.1145/3379337.3415900},
  urldate = {2021-04-11},
  eventtitle = {{{UIST}} '20: {{The}} 33rd {{Annual ACM Symposium}} on {{User Interface Software}} and {{Technology}}},
  file = {/Users/kapayakatongo/Zotero/storage/PVPE59LK/Zhang et al. - 2020 - Interactive Program Synthesis by Augmented Example.pdf},
  isbn = {978-1-4503-7514-6},
  langid = {english}
}

@article{zhang2021,
  title = {Interpretable {{Program Synthesis}}},
  author = {Zhang, Tianyi and Vaithilingam, Priyan and Chen, Zhiyang and Wang, Xinyu and Zhu, Yuanli and Glassman, Elena L},
  date = {2021},
  pages = {16},
  file = {/Users/kapayakatongo/Zotero/storage/JYNB5862/Zhang et al. - 2021 - Interpretable Program Synthesis.pdf},
  langid = {english}
}

@online{zotero-224,
  title = {Greasespot},
  url = {https://www.greasespot.net/},
  urldate = {2021-04-20},
  abstract = {The weblog about greasemonkey},
  file = {/Users/kapayakatongo/Zotero/storage/3SFVFDQ3/www.greasespot.net.html}
}


